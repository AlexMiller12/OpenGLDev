#version 400
layout( quads ) in;

// This function comes right out of the author's implementation
// It's a B-spline basis evaluation via deBoor pyramid

//---------------------------------------------------------CONSTANTS:

float ONE_THIRD = 1.0 / 3.0;
float TWO_THIRDS = 1.0 / 2.0;

//---------------------------------------------------------VARIABLES:

in vec3 in_vertexPositions[];

out vec3 out_position;
out vec3 out_normal;

uniform mat4 u_mvp;
uniform mat4 u_model;


//-----------------------------------------------------------HELPERS:

void evaluateCubicBSpline( float u, 
						   inout vec4 basis, 
						   inout vec4 basisDerivitive )
{
 	float t = u;
    float s = 1.0 - u;

	float c0 = s * ( 0.5 * s );
	float c1 = t * ( s + 0.5 * t ) + s * ( 0.5 * s + t );
	float c2 = s * ( 0.5 * t );

    basis[0] =	ONE_THIRD * s * c0;

    basis[1] = ( TWO_THIRDS * s + t ) * c0 + 
    		   ( TWO_THIRDS * s + ONE_THIRD * t ) * c1;

    basis[2] = ( ONE_THIRD * s + TWO_THIRDS * t ) * c1 + 
     		   ( s + TWO_THIRDS * t ) * c2;

    basis[3] = ONE_THIRD * t  * c2;

    basisDerivitive[0] = -c0;
    basisDerivitive[1] = c0 - c1;
    basisDerivitive[2] = c1 - c2;
    basisDerivitive[3] = c2;
}

//--------------------------------------------------------------MAIN:

void main()
{
	vec4 basis;
	vec4 basisDerivitive;

	evaluateCubicBSpline( gl_TessCoord.x, basis, basisDerivitive );

	vec3 cpBasis[4] = vec3[]( vec3(0), vec3(0), vec3(0), vec3(0) );
	vec3 cpBasisDerivitive[4] = vec3[]( vec3(0), vec3(0), vec3(0), vec3(0) );

	for( int i = 0; i < 4; i++ )
	{
		// cpBasis[i] = vec3(); TODO ?
		for( int j = 0; j < 4; j++ )
		{
			vec3 controlPoint = in_vertexPositions[ 4 * i + j];
			cpBasis[i] += controlPoint * basis[j];
			cpBasisDerivitive[i] += controlPoint * basisDerivitive[j];
		}
	}

	evaluateCubicBSpline( gl_TessCoord.y, basis, basisDerivitive );

	vec3 worldPos = vec3( 0 );
	vec3 tangent = vec3( 0 );
	vec3 biTangent = vec3( 0 );

	for( int i = 0; i < 4; i++ )
	{
		worldPos += basis[i] * cpBasis[i];
		tangent += basis[i] * cpBasisDerivitive[i];
		biTangent += basisDerivitive[i] * cpBasis[i];
	}
	vec3 normal = normalize( cross( biTangent, tangent ) );

	out_normal = mat3( u_model ) * normal;
	out_position = worldPos;

	gl_Position = u_mvp * vec4( worldPos, 1.0 );
}